# Segmentation of seismic facies
Этот репозиторий содержит реализацию обучения модели U-Net для задачи сегментации изображений. Модель обучается на наборе данных, содержащем суммарный сейсмический куб и куб выделенных сейсмических фаций в формате numpy.ndarray, и может быть использована для сегментации сейсмических разрезов, полученных на этой же территории (континентальный шельф Северного моря у берегов Нидерландов), или может быть переобучена для нового набора данных.

## Кастомный датасет SegmentationDataset
Класс `SegmentationDataset` наследуется от `torch.utils.data.Dataset` и предназначен для работы с массивами изображений и масок в формате NumPy. Изображения нормализуются, а маски преобразуются в one-hot encoding.

## Архитектура модели
Используется архитектура U-Net с энкодером на основе ResNet18. Модель поддерживает многоклассовую сегментацию с активацией `softmax` на выходе. Веса энкодера инициализируются предобученными на ImageNet.
```python
model = Unet(
    encoder_name="resnet18",  # Используем ResNet18 в качестве энкодера
    encoder_weights="imagenet",  # Предобученные веса на ImageNet
    in_channels=1,  # 1 канал для grayscale изображений
    classes=num_classes,  # Количество классов
    activation="softmax",  # softmax для многоклассовой классификации
)
```
## Функция потерь и оптимизатор
Для многоклассовой классификации используется функция потерь `CrossEntropyLoss`.<p> 

Оптимизатор — `AdamW` с L2-регуляризацией.<p>

Планировщик `ReduceLROnPlateau` динамически изменяет скорость обучения в зависимости от качества модели на валидационной выборке.
  
## Метрика качества (IoU)
Реализована функция `calculate_iou` для вычисления Intersection over Union (IoU) для многоклассовой сегментации, IoU вычисляется для каждого класса и усредняется.
```python
def calculate_iou(preds, masks):
    preds = torch.argmax(preds, dim=1)  # Преобразование предсказаний в индексы классов
    masks = torch.argmax(masks, dim=1)  # Преобразование масок в индексы классов
    iou = 0.0
    for cls in range(num_classes):
        pred_cls = (preds == cls).float()
        mask_cls = (masks == cls).float()
        intersection = (pred_cls * mask_cls).sum()
        union = pred_cls.sum() + mask_cls.sum() - intersection
        iou += (intersection + 1e-6) / (union + 1e-6)  
    return iou / num_classes  # Среднее IoU по всем классам
```

## Процесс обучения и валидации
В функции `train` происходит обучение модели на обучающей выборке.<p>

В функции `validate` оценивается качество модели на валидационной выборке.<p>

Лучшая модель сохраняется в файл `best_unet_segmentation.pth`.

## Использование
Код поддерживает обучение на GPU (если доступно).<p>

Пример использования включает разделение данных на обучающую и валидационную выборки, создание датасетов и DataLoader, а также запуск обучения.

## Графики метрик и пример использования 

Как мы можем видеть из такого поведения функции потерь и IoU - модель хорошо проучивается и не переобучается, поскольку разрыв между валидацией и обучением не высок:
![Графики](https://github.com/user-attachments/assets/74e99468-5a8c-48a2-b873-1351e6440dbf)
Пример использование обученной нейронной сети на сейсмическом профиле, не участвующем в процессе обучения: 
![Разрезы](https://github.com/user-attachments/assets/5867fefb-dda0-4ce8-b9b2-c5e4ce3b2aa8)

## Лицензия
Этот проект распространяется под лицензией MIT. Подробности см. в файле `LICENSE`.
## Ссылки на данные
https://zenodo.org/records/3755060<p>
https://library.seg.org/doi/10.1190/INT-2018-0249.1

